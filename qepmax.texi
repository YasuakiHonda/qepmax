@menu
* Introduction to qepmax::
* Functions and Variables for qepmax::
@end menu

@node Introduction to qepmax, , , 
@section Introduction to qepmax

@code{Qepmax} is a @code{Qepcad B} - Maxima interfacing module written in
Maxima language and Common Lisp. As @code{Qepcad B} provides so 
called quantifier elimination in the real domain, @code{qepmax}
adds this functionality to Maxima computer algebra system.

With using quantifier elimination (Q.E. in short), a variety of problems 
can be expressed and solved. Optimization problems with multi-variate 
polynomials with equality and inequality constraints can be exactly(!) and
symbolically(!!) solved. 

@code{Qepmax} requires @code{Qepcad B}, developed at and distributed from
the United States Naval Academy. @code{Qepmax} users are suggested to visit 
@url{http://www.usna.edu/CS/~qepcad/B/QEPCAD.html, Qepcad B homepage} to 
become familier with @code{Qepcad B}, to obtain the distribution package, and
to know how to install it.

Lincese terms of @code{Qepmax} can be found in each source files. 
@code{Qepmax} package is in GPL v2.

@code{Qepmax} package is written by Yasuaki Honda, then Prof. 
Dr. Reinhard Oldenburg of Goethe-Universit√§t Frankfurt has
contributed the improvements for allowing the use of logical 
operators and rational functions as well as better function
interface.

Further, ehito-san has contributed the improvement of the
treatment of rational functions.

Hereafter is the quick introduction of:
@itemize @bullet
@item
What is Quantifier Elimination?
@item
What does Qepcad B do?
@item
What is qepmax package and how to use it?
@end itemize

@b{What is Quantifier Elimination}
A large size of problems can be expressed as a first order
predicate logic with the following properties:
@itemize @bullet
@item
variables are in real number domain
@item
predicates are =, <, >, <=, >=, #(not equal)
@item
terms are polinomials or rational functions
@end itemize

A logical formula with some of its variables quntified is 
called a Talski sentence. 
Example: a circle @math{x^2+y^2=1} and a line @math{y=x/2+1/3} 
crosses with each other. Talski sentence for this is:
@math{E x, E y, x^2+y^2=1 and y=x/2+1/3}
where E denotes the existential quantifier.

The quntifier elimination is a technique to obtain the
equivarent condition to the given Talski sentence. The
resulted condition does not contain any quantified variables.

By using the quantifier elimination technique, we can obtain 
an equivarent condition:
@math{true}
meaning that, yes, there is a point (x,y) which satisfies
both circle and line formulas.

On the other hand, from
@math{E x, E y, x^2+y^2=1 and y=x/2+5}
we will obtain
@math{false}
since there is no such intersection point (x,y).

Further more, considering the following Talski sentence with free variable a:
@math{E x, E y, x^2+y^2=1 and y=x/2+a}

Using the quantifier elimination, we obtain a condition on a:
@math{4*a^2-5<=0}

So, while a is in this range, the circle and the line cross, but
they don't cross if a is not in the range above.

@b{What does Qepcad B do?}
Qepcad B is a software that implements a quantifier elimination
algorithm called Cylindrical Algebraic Decomposition (CAD).
The software is developed by Prof. Chris Brown of US Naval Academy.
The homepage of the software is:
@url{http://www.usna.edu/CS/~qepcad/B/QEPCAD.html}

On starting the program Qepcad B, the interactive session starts.
You give a list of variables, number of free variables,
a list of quntified variables, and a Talski sentence with Qepcad B 
syntax during the session. Alternatively, you can supply all
such information in a file and Qepcad B processes it.
Then the program computes the equivarent condition to the
specified Talski sentence, only including the free variables. 

It is a fun to use Qepcad B directly from its command line 
interface, as it provides many commands and options to use
during the interactive sessions. 

@b{What is qepmax package and how to use it?}
Qepmax is a Maxima package that calls Qepcad B internally using
sysmtem() function to process Talski sentence represented using
Maxima syntax.

Assuming it is correctly installed according to INSTALL, you
can load the package by:
@example
(%i1) load(``qepmax.mac'');
@end example

Qepmax package provides a function @code{qe(QFList, aLogicalExp)}.
@code{QFList} is a list of quantified variables. @code{aLogicalExp} is an
expression in the real domain. You can use =,<,>,<=,>=,# as
the predicates, polynomials and rational functions as terms,
and %and, %or, %not, %implies as the logical operators.
In polimomials and rational functions, you can use rational
numbers and variables as coefficients.

The function qe() generates a temporary file that can be used for the
input of Qepcad B. Then Qepcad B is invoked with the file contents
supplied from standard input. Qepcad generates an output file in which
quantifier elimination result is written.

Then @code{qe()} read the output file and translate the result into Maxima
formula and return it from qe(). You can of course use it for the futher 
computation using Maxima.

@opencatbox
@category{Symbolic methods}  @category{Optimization} @category{Share packages} @category{Package qepmax}
@closecatbox

@node Functions and Variables for qepmax, , ,
@section Functions and Variables for qepmax

@deffn {Function} qe (@var{flist}, @var{varlist}, @var{guess} [, @var{tolerance}, @var{jacobian}])

Compute the point that minimizes the sum of the squares of the
functions in the list @var{flist}.  The variables are in the list
@var{varlist}.  An initial guess of the optimum point must be provided
in @var{guess}.  

The optional keyword arguments, @var{tolerance} and @var{jacobian}
provide some control over the algorithm.  @var{tolerance} is the
estimated relative error desired in the sum of squares.
@var{jacobian} can be used to specify the Jacobian.  If @var{jacobian}
is not given or is @code{true} (the default), the Jacobian is computed
from @var{flist}.  If @var{jacobian} is @code{false}, a numerical
approximation is used.

@code{minpack_lsquares} returns a list.  The first item is the
estimated solution; the second is the sum of squares, and the third
indicates the success of the algorithm.  The possible values are

@table @code
@item 0
improper input parameters.
@item 1
algorithm estimates that the relative error in the sum of squares is
at most @code{tolerance}. 
@item 2
algorithm estimates that the relative error between x and the solution
is at most @code{tolerance}. 
@item 3
conditions for info = 1 and info = 2 both hold.
@item 4
fvec is orthogonal to the columns of the jacobian to machine
precision. 
@item 5
number of calls to fcn with iflag = 1 has reached 100*(n+1).
@item 6
tol is too small. no further reduction in the sum of squares is
possible. 
@item 7
tol is too small. no further improvement in the approximate solution x
is possible. 
@end table

@example
/* Problem 6: Powell singular function */
(%i1) powell(x1,x2,x3,x4) := 
         [x1+10*x2, sqrt(5)*(x3-x4), (x2-2*x3)^2, 
              sqrt(10)*(x1-x4)^2]$
(%i2) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4], 
                       [3,-1,0,1]);
(%o2) [[1.652117596168394e-17, - 1.652117596168393e-18, 
        2.643388153869468e-18, 2.643388153869468e-18], 
       6.109327859207777e-34, 4] 
@end example

@example
/* Same problem but use numerical approximation to Jacobian */
(%i3) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4], 
                       [3,-1,0,1], jacobian = false);
(%o3) [[5.060282149485331e-11, - 5.060282149491206e-12, 
        2.179447843547218e-11, 2.179447843547218e-11], 
       3.534491794847031e-21, 5]
@end example

@end deffn

@deffn {Function} minpack_solve (@var{flist}, @var{varlist}, @var{guess} [, @var{tolerance}, @var{jacobian}])
Solve a system of @code{n} equations in @code{n} unknowns.
The @code{n} equations are given in the list @var{flist}, and the
unknowns are in @var{varlist}.  An initial guess of the solution must
be provided in @var{guess}.

The optional keyword arguments, @var{tolerance} and @var{jacobian}
provide some control over the algorithm.  @var{tolerance} is the
estimated relative error desired in the sum of squares.
@var{jacobian} can be used to specify the Jacobian.  If @var{jacobian}
is not given or is @code{true} (the default), the Jacobian is computed
from @var{flist}.  If @var{jacobian} is @code{false}, a numerical
approximation is used.

@code{minpack_solve} returns a list.  The first item is the
estimated solution; the second is the sum of squares, and the third
indicates the success of the algorithm.  The possible values are

@table @code
@item 0
improper input parameters.
@item 1
algorithm estimates that the relative error in the solution is
at most @code{tolerance}. 
@item 2
number of calls to fcn with iflag = 1 has reached 100*(n+1).
@item 3
tol is too small. no further reduction in the sum of squares is
possible. 
@item 4
Iteration is not making good progress.
@end table

@example
@end example

@end deffn

@c Local Variables: 
@c mode: texinfo
@c TeX-master: "include-maxima"
@c End: 
